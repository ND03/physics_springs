# Tiny Physics

## Постановка задачи: 
Симуляция взаимодействия трех тел и трех пружин между ними
## Способ реализации: 
Создание графической визуализации на языке C++ при помощи графической библиотеки SFML
## План:
   * [Создание тела и симуляция его движения](#chapter-3)
   * [Создание связи между телами](#chapter-4)
   * [Обобщение для 3 тел](#chapter-5)
   * [Обобщение для N тел](#chapter-6)
<a id="chapter-3"></a>
## Создание тела
Для упрощения расчетов, будем считать тело материальной точкой (Не учитывать его форму и вращение), которая ведет себя, как центр масс. 
Тогда для описания динамики тела нам понадобится его положение, скорость и ускорение. Для их хранения будем использовать класс Vector из файла Vector.h


Линейное движение тела описывается уравнением:
        
      r = r0 + V*dt
Где <b>r</b> - радиус-вектор положения (далее - положение), <b>r0</b> - радиус-вектор начального положения тела, <b>V</b> - его скорость, а <b>dt</b> - время, за которое это перемещение было совершено.

Однако, такой способ описания динамики тела не всегда покрывает поставленную задачу полностью, поскольку скорость тела в пределах поставленной задачи не является постоянной величиной. Значение скорости при линейном ускорении описывается следующим уравнением:

      V = V0 + a*dt
Где <b>V</b> - скорость тела спустя все то же время <b>dt</b>, <b>a</b> - ускорение тела, а <b>V0</b> - начальная скорость. Второй закон Ньютона гласит:
      
      F = m*a => a = F/m
Где <b>а</b> - ускорение тела массы <b>m</b>, а <b>F</b> - сумма сил, действующих на это тело.

Таким образом, мы получаем систему уравнений:
      
      r = V*dt + r0; (1)
      V = a*dt + V0; (2)
      a = F/m;       (3)
      
Однако становится очевидно, что эти расчеты имеют смысл лишь только если сила за все время dt не меняется. Потому мы приходим к методу итеративного интегрирования, которое представляет из себя перерасчет всех величин каждые dt секунд. При этом, после этого <b>r0</b> станет равно <b>r </b>, a <b>V0</b> примет значение <b>V</b>. Таким образом, код на C++, отвечающий за обновление положения тела примет вид:

      r += V*dt;
      V += (F/m)*dt;
Тем не менее, и здесь не обходится без подводных камней. Одним из них является погрешность вычислений. Во-первых, нельзя брать dt слишком большим, поскольку изменение значения силы будет происходить крайне редко. Для наглядности, рассмотрим сразу несколько траекторий тел с разными шагами интегрирования на визуализации действия гравитации:

![dt_diff](https://github.com/kntzn/physics_springs/blob/master/Engine/Engine/img/dt_diff.png)

Отчетливо видно, как с увеличением шага интегрирования растет удаление от истиного положения тела (погрешность расчетов). 

Во-вторых, запись уравнений в таком порядке, как в примере с кодом выше (такая запись, кстати, называется явным интегрированием по Эйлеру), приведет к погрешности, поскольку обновление координат происходит до обновления скорости. Чтобы внести ясность, представим результат единичного выполнения этих двух строк:
      
      r = 0, V = 0, F = 1, m = 1;
      r += V*dt;
      V += (F/m)*dt;
      
Первая строка (Уравнение 1) не увеличит <b>r</b>, поскольку <b>V</b> равно нулю. А вот скорость, в свою очередь, возрастет на <b>dt</b>: 
      
      V += (F/m)*dt => V += 1/1*dt => V += dt

Однако простая перестановка этих двух строк исправляет ситуацию. Этот метод называется неявным интегрированием по Эйлеру. Создадим функцию обновления тела, используя этот метод:

      void updatePoint (FloatVector2D &r, FloatVector2D &V, FloatVector2D &F, const float dt, const float mass)
         {
         V += F/mass;
         r += V*dt;
         }

В качестве параметров она принимает всю информацию о теле, а так же шаг инегрирования <b>dt</b>.
